# -*- coding: utf-8 -*-

"""
  JGV_Annotation.py
  JGV is a Python3 package for an embed genomic viewer in Jupyter notebook
  Do not try to import the package in a non-interactive environment

  Copyright 2016 Adrien Leger <aleg@ebi.ac.ul>
  [Github](https://github.com/a-slide)
  
  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or(at your option) any later version
  
  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
  (http://www.gnu.org/licenses/gpl-3.0.html).
  
  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
"""

# Strandard library imports
from collections import OrderedDict, Counter
from os import access, R_OK
import gzip
import csv

# Third party import
import pandas as pd

# Local lib import
from JGV_helper_fun import *
from JGV_helper_fun import jprint as print

#~~~~~~~CLASS~~~~~~~#

class Reference(object):
    
    #~~~~~~~FUNDAMENTAL METHODS~~~~~~~#
    
    def __init__ (self, fp, name=None, verbose=False):
        """
         * fp
            A fasta file containing the reference sequences OR an tab separated index file containing at least 2 columns with the seqid and
            the length in base (like a .fa.fai file generated by samtools faidx).
            The a fasta option will take more time as the file has to be parsed to get the seqid and length of sequences. A 2 column index
            tsv file will be automatically generated. This file can be used latter as an index file. Both fasta and infex file can be gziped 
        *  name
            Name of the data file that will be used as track name for plotting. If not given, will be deduced from fp file name
        * verbose
            If True, will print more information during initialisation and calls of all the object methods.
        """
        #Save self variable
        self.name= name if name else file_basename(fp)
        self.verbose=verbose
        
        # Verify that the file is readable
        if not access(fp, R_OK):
            raise IOError ("{} is not readable".format(fp))
        
        # If the file is in fasta format
        if extensions(fp)[0] in ["fa", "fasta"]:
            if self.verbose: print ("Parsing fasta file")
            
            # File handling for both uncompressed or compressed fasta file
            if fp.endswith(".gz"):
                open_fun, open_mode = gzip.open, "rt"
            else:
                open_fun, open_mode = open, "r"
            
            # Parse fasta file seqid and count the length of each sequence 
            with open_fun(fp, open_mode) as f:
                c = Counter()
                for l in f:
                    if l.startswith(">"):
                        seqid = l[1:].split()[0].strip()
                    else:
                        c[seqid]+=len(l.strip())
            
            # Transform the counter in a Dataframe and sort by length 
            self.seq_list =  pd.DataFrame.from_dict(c, orient='index', dtype=int)
            self.seq_list.columns = ['length']
            self.seq_list.index.name = 'seqid'
            self.seq_list.sort_values(by="length", inplace=True, ascending=False)
            
            # Write the index in a file for quicker loading next time
            index_file = "{}/{}.tsv".format(dir_path(fp), file_basename(fp))
            if self.verbose: print ("Write a fasta index file: {}".format(index_file))
            self.seq_list.to_csv(index_file, sep="\t", header=False, index=True, quoting=csv.QUOTE_NONE)
            
        # In the case the file is not in fasta format, try to parse it as a 2 columns tabulated file with seqid and length for each sequence
        else:
            if self.verbose: print ("Assume the file is a fasta index")
            self.seq_list = pd.read_csv (fp, usecols=[0,1], sep ="\t", names=["seqid", "length"], index_col=0)
            self.seq_list.sort_values(by="length", inplace=True, ascending=False)
        
        if self.verbose: print("Total number of sequences found: {}".format(len(self.seq_list)))
            
            
    def __str__(self):
        """readable description of the object"""
        msg = "{} instance\n".format(self.__class__.__name__) 
        msg+= "\tParameters list\n"
        msg+="\tname\t{}\n".format(self.name)
        msg+="\tverbose\t{}\n".format(self.verbose)
        msg+="\t\tseqid\tlength\n"
        for seqid, val in self.seq_list.head(5).iterrows():
            msg+="\t\t{}\t{}\n".format(seqid, val.length)
        msg+="\t\t... total sequences\t{}\n".format(len(self.seq_list))
        return (msg)
        
    def __repr__ (self):
        return ("{}-{}".format(self.__class__.__name__, self.name))
        
    #~~~~~~~PROPERTY METHODS~~~~~~~#
        
    @property
    def seqid_list(self):
        """List of all the sequence ids found in the annotation file"""
        return self.seq_list.index
        
    #~~~~~~~PUBLIC METHODS~~~~~~~#
    
    def get_seqid_len (self, seqid):
        """ Return the length of a given seqid"""
        return self.seq_list.loc[seqid]["length"]
