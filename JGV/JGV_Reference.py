# -*- coding: utf-8 -*-

# Strandard library imports
from collections import OrderedDict, Counter, namedtuple
from os import access, R_OK
import gzip
import csv

# Third party import
import pandas as pd
from pycl.pycl import extensions_list, file_basename, dir_path, jprint, is_readable_file

#~~~~~~~CLASS~~~~~~~#
class Reference(object):
    """
    Parse a fasta reference file or a fasta index and save the list of reference sequences ids and their lengths
    """

    #~~~~~~~FUNDAMENTAL METHODS~~~~~~~#
    def __init__ (self, fp, name=None, refid_list=[], output_index=False, verbose=False, **kwargs):
        """
         * fp
            A fasta file containing the reference sequences OR an tab separated index file containing at least 2 columns
            with the refid and the length in bases (like a .fa.fai file generated by samtools faidx, or with the
            output_index option of this function)
            The fasta option will take more time as the file has to be parsed to get the refid and length of sequences.
            Both fasta and infex file can be gziped
        *  name
            Name of the data file that will be used as track name for plotting. If not given, will be deduced from fp
            file name
        * refid_list
            list of reference sequence id to select from the data file, by default all [ DEFAULT: [] ]
        * output_index
            If True will write a simple A 2 column index tsv file containing the Reference sequence ids and their
            lengths [ DEFAULT: False ]
        """
        # Verify that the file is readable
        is_readable_file(fp)

        #Save self variable
        self.fp = fp
        self.name = name if name else file_basename(fp)
        self.ext = extensions_list(fp)[0]

        # If the file is in fasta format
        if self.ext in ["fa", "fasta"]:
            if verbose: jprint ("Parsing fasta file")

            # File handling for both uncompressed or compressed fasta file
            if fp.endswith(".gz"):
                open_fun, open_mode = gzip.open, "rt"
            else:
                open_fun, open_mode = open, "r"

            # Parse fasta file refid and count the length of each sequence if in the refid_list
            with open_fun(fp, open_mode) as f:
                d = OrderedDict()
                last_ref = None
                for l in f:
                    if l.startswith(">"):
                        refid = l[1:].split()[0].strip()
                        if not refid_list or refid in refid_list:
                            d[refid] = 0
                            last_ref = refid
                        else:
                            last_ref = None
                    elif last_ref:
                        d[last_ref] += len(l.strip())
            
            # Check if sequences found 
            assert d, "No Sequence found"
            
            # Transform the counter in a Dataframe and sort by length
            self.d = pd.Series(d, name="length", dtype = "int64")
            self.d.sort_values(inplace=True, ascending=False)

            # Write the index in a file for quicker loading next time
            if output_index:
                index_file = "{}/{}.tsv".format(dir_path(fp), file_basename(fp))
                if verbose: jprint ("Write a fasta index file: {}".format(index_file))
                self.d.to_csv(index_file, sep="\t")

        # In the case the file is not in fasta format, try to parse it as a 2 columns tabulated file with refid and length for each sequence
        else:
            if verbose: jprint ("Assume the file is a fasta index")
            self.d = pd.read_csv(fp, sep="\t", squeeze=True, comment="#",  usecols=[0,1], index_col=0, header=None)
            if refid_list: self.d = self.d[(self.d.index.isin(refid_list))]
            self.d.name= "length"
            self.d.sort_values(inplace=True, ascending=False)

        if verbose:
            jprint ("\tFound {} reference sequences".format(self.refid_count))

    def __repr__ (self):
        return ("{}: {} - Reference count {}".format(self.__class__.__name__, self.name, self.refid_count))

    #~~~~~~~PROPERTY METHODS~~~~~~~#
    @property
    def refid_list(self):
        """List of all the sequence ids found in the annotation file"""
        return list(self.d.index)

    @property
    def refid_count(self):
        """Number of unique reference sequence ids found"""
        return len(self.d)

    #~~~~~~~PUBLIC METHODS~~~~~~~#
    def get_refid_len (self, refid, verbose=False, **kwargs):
        """ Return the length of a given refid, If the reference is not found return None"""
        if refid not in self.d:
            if verbose: jprint ("The reference sequence {} was not found in the reference list".format(refid))
            return None
        else:
            return self.d[refid]
