# -*- coding: utf-8 -*-

"""
  JGV.py
  JGV is a Python3 package for an embed genomic viewer in Jupyter notebook. Do not import the package in a non-interactive environment

  Copyright 2016 Adrien Leger <aleg@ebi.ac.ul>
  [Github](https://github.com/a-slide)
  
  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or(at your option) any later version
  
  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
  (http://www.gnu.org/licenses/gpl-3.0.html).
  
  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation,
  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
"""

# Strandard library imports
import csv
from collections import OrderedDict, Counter
from os import access, R_OK
from gzip import open as gopen
import warnings
from statistics import median

# Local lib import
from JGV_helper_fun import *
from JGV_annotation import gff3_line

# Third party import
import pandas as pd
import pysam
# Matplotlib packages
import pylab as pl
from matplotlib.patches import FancyArrowPatch as arrow
from matplotlib.gridspec import GridSpec

class JGV(object):
    
    #~~~~~~~FUNDAMENTAL METHODS~~~~~~~#
    
    def __init__ (self, fasta=None, index=None, verbose=False):
        """
        Create an JGV reference containing a list of seqid retrieved from a fasta file or a fasta index file (fai). One of the 2 files has
        to be given to initialise the object.
        * fasta
            A fasta file containing the reference sequences. The file will be parsed to get the name and length of the sequences, but the
            sequence per se do not need to be saved. A tab separated file containing the name of the sequences and the length will be
            written in the same dir as the fasta file. this file can be used latter as an index file. Can be gziped or not.
        * index
            A file containing at least 2 columns with the seqid and the length in base. It could be a fai file generated by samtools faidx
            or any other tab separated format. This option is much faster than the fasta option. Can be gziped or not.
        * verbose
            If True, will print more information during initialisation and calls of all the object methods.
        """
        # Save self variables
        self.verbose = verbose
        self.reference = fasta_parser
        self.annotation_dict = None
        self.alignment_dict = None 
        
        # Generate the list of seqid + their length        
        if not fasta and not index:
            raise ValueError ("A fasta file or a fasta index has to be given")
        
        if self.verbose: print("Initialize JGV with a reference genome")
        
        if self.verbose: print("\tTotal number of sequences found: {}".format(len( ##### self.seqid_dict #####)))
        
    def __str__(self):
        """ Readable description of the object """
        msg = "{} instance\n".format(self.__class__.__name__)
        msg+= "\tParameters list\n"
        # list all values in object dict in alphabetical order
        sorted_d = OrderedDict(sorted(self.__dict__.items(), key=lambda t: t[0]))
        for k,v in sorted_d.items():
            msg+= "\t{}\t{}\n".format(k, v)
        return (msg)

    #~~~~~~~PRIVATE METHODS~~~~~~~#
    
    def _fasta_parser (self, fp):
        """ Parse a fasta file and return a dict """
        f = None
        try:
            f = gopen(fp, "rt") if fp.endswith(".gz") else open(fp, "r")
            c = Counter()
            for l in f:
                if l.startswith(">"):
                    seqid = l[1:].split()[0].strip()
                else:
                    c[seqid]+=len(l.strip())
        finally:
            if f:
                f.close()
        return OrderedDict(c.most_common())
    
    def _index_parser (self, fp):
        """ Parse a fasta index file and return a dict"""
        f = None
        try:
            f = gopen(fp, "rt") if fp.endswith(".gz") else open(fp, "r")
            d = OrderedDict()
            for l in f:
                ls = l.split("\t")
                assert len(ls) >= 2, "The index file is incorectly formated"
                seqid = ls[0].strip()
                length = int(ls[1].strip())
                d[seqid] = length
        finally:
            if f:
                f.close()
        return d

    #~~~~~~~GETTERS METHODS~~~~~~~#
    
    def get_seqid (self, max=None):
        pass
    
    def get_annotation_track (self):
        pass
    
    def get_alignment_track (self):
        pass
        

    #~~~~~~~PUBLIC METHODS~~~~~~~#
    
    def add_annotation (self, fp, name=None):
        """
        Verify, eventually sort and index, and link a GFF3 annotation file to the object for subsequent plotting of the feature localization
        * fp
            A standard gff3 file (http://www.ensembl.org/info/website/upload/gff3.html) containing all feature annotation. Could be
            uncompressed or archived in the following format ("gz"). Ideally already indexed with tabix bgzip. If not the program will sort
            the features and index the file (can take time)
        *  name
            Name of the data file that will be used as track name for plotting. If not given, will be inferred from the file name
        """
        # Verify that the file is readable
        if not access(fp, R_OK):
            raise IOError ("{} is not readable".format(fp))
        # Extract basename and extension for further 
        extension = get_extensions(fp)
        if not name:
            name = get_basename(fp)
        # Verify that the file is in gff3 format
        if extension not in [".gff3.gz", ".gff3"]:
            raise ValueError ("The file is not in gff3 format (.gff3.gz, .gff3). Please provide a correctly formated file")

        # If not indexed, sort and compress and index the original file with tabix 
        if not access(fp+".tbi", R_OK):
           
            # Import in a panda dataframe, remove empty row, and convert coordinates in integer
            if self.verbose:  print("Indexing file with tabix\n\tImport annotation file and clean data")
            df = pd.read_csv(fp, names=["seqname","source","feature","start","stop","score","strand","frame","attribute"], sep="\t")
            df.dropna(inplace=True)
            df[['start', 'stop']] = df[['start', 'stop']].astype(int)
            
            # Sort the dataframe
            if self.verbose: print("\tSort lines by coordinates")
            df.sort_values(by=["seqname","start","stop"], inplace=True)
            # Remove the extension, name the output file and write in file
            temp_file = fp[:-len(extension)]+"_sorted.gff3"
            df.to_csv(temp_file, sep="\t", header=False, index=False)
            
            # Compress and index the sorted file with tabix
            if self.verbose: print("\tCompress and index with tabix")
            fp = pysam.tabix_index(temp_file, preset="gff", force=True)
        
        # Common steps if existing or generated index
        with pysam.TabixFile(fp, parser=pysam.asGTF()) as gff:
            if self.verbose: print("Gff file indexed")
            # Verify the sequence id 
            for seqid in [i.decode() for i in gff.contigs]:
                if seqid not in  ##### self.seqid_dict #####:
                    warnings.warn("{} seqid from annotation file not found in the initial fasta file".format(seqid))
            self.annotation_dict[name] = gff.filename.decode()
    
    def add_alignment (self, fp, name=None):
        """
        Verify, eventually index and link a BAM alignment file to the object for subsequent plotting of the read coverage 
        * fp
            A standard BAM file containing aligned reads against the reference genome given at initialisation of the JGV object.  Any
            aligner yielding a standard BAM file is compatible. The viewer is able to represent split read generated by RNAseq aligner.
            The file need to be sorted by coordinates (using Samtools sort for example). Ideally the file would also be already indexed with
            samtools index. If not the program will index the file (can take time)
        *  name
            Name of the data file that will be used as track name for plotting. If not given, will be inferred from the file 
        """
        # Verify that the file is readable
        if not access(fp, R_OK):
            raise IOError ("{} is not readable".format(fp))
        # Extract basename and extension for further 
        extension = get_extensions(fp)
        if not name:
            name = get_basename(fp)
        # Verify that the file is in bam format
        if extension not in [".bam"]:
            raise ValueError ("The file is not in BAM format (.bam). Please provide a correctly formated file")
        
        with pysam.AlignmentFile(fp) as bam:
            # If not bam index available
            if not bam.has_index():
                # If no index but file sorted
                if bam.header["HD"]['SO'] == "coordinate":
                    if self.verbose: print("Indexing bam file")
                    pysam.index(fp, catch_stdout=False)
                else:
                    raise UserWarning ("The file bam needs to be sorted by coordinates to be processed")
            
            assert bam.has_index(), "Bam file is not indexed ?"
            if self.verbose: print("Bam file indexed")
            for seqid in bam.references:
                if seqid not in  ##### self.seqid_dict #####:
                    warnings.warn("{} seqid from annotation file not found in the initial fasta file".format(seqid))
            self.alignment_dict[name] =  bam.filename.decode()    
    
    def plot_interval(self,
        seqid, start=None, end=None,
        alignment_tracks=[],
        alignment_n_step=500,
        alignment_yscale="linear",
        alignment_mode="auto",
        annotation_tracks=[],
        annotation_feature_types=[],
        annotation_label=False,
        annotation_overlap_offset=None,
        annotation_max_level=None,
        plot_style="ggplot",
        track_width=30,
        alignment_track_height=10,
        annotation_track_height=2):
        """
        Generate a figure with alignment coverage on the top and annotation tracks on the bottom
        * seqid
            Name of the sequence from the initial fasta file to display
        * start
            Start of the window to display. If not given will start from 0 [ DEFAULT: None ]
        * end
            End of the window to display. If not given will start from end of the sequence [ DEFAULT: None ]
        * alignment_tracks
            List of name of the alignment tracks to display. If not given will display all tracks added [ DEFAULT: [] ]
        * alignment_n_step
            Number of alignment count bins to divide the displayed window. Low number will result in low resolution but will be faster. The
            default value is a decent compromise between speed and precision [ DEFAULT: 500 ]
        * alignment_yscale  Scaling of the y axis for the alignment track ('linear'|'log') [ DEFAULT: "linear" ]
        * alignment_mode
            Mode to parse and represent the alignment track ("auto"|"read_count"|"base_coverage"). The "read_count" is fast for large
            regions, but do not account for spliced reads. In "auto" mode it is automatically selected for intervals larger than 5000000.
            The "base_coverage" mode compute the median base coverage per step. It is faster for low coverage and small intervals.
            In "auto" mode it is automatically selected for intervals larger smaller than 5000000 [ DEFAULT: "auto" ]
        * annotation_tracks
            List of name of the annotation tracks to display. If not given will display all tracks added [ DEFAULT: [] ]
        * annotation_feature_types
            List of features types for which a track will be displayed if at least 1 feature of this type was found in the requested
            interval ( "exon"|"transcript"|"gene"|"CDS"...). If not given, all features type found in the interval will be displayed
            [ DEFAULT: [] ]
        * annotation_label
            If True the label of the feature will be displayed on the track. To be avoid for intervals containing many features, for
            performance and readability concerns.
            [ DEFAULT: False ]
        * annotation_overlap_offset
            Minimal space between 2 features on the same line of the annotation track. If not given, will be automatically computed to be
            1/400 of the interval [ DEFAULT: None ]
        * annotation_max_level
            Maximal number of feature lines per annotation track. If they do not fit in the lines the extra features will be discarded. If
            not given, not the number of lines is not capped (can result in long plotting time for very dense annotations)
            [ DEFAULT: None ]
        * plot_style
            Default plot style for pyplot ('grayscale'|'bmh'|'ggplot'|'dark_background'|'classic'|'fivethirtyeight'...)[ DEFAULT: "ggplot" ]
        * track_width
            Width of the plotting area [ DEFAULT: 30]
        * alignment_track_height
            Heigh of each alignment track [ DEFAULT: 10 ]
        * annotation_track_height
            Heigh of each annotation track [ DEFAULT: 2 ]
        """
        # Verify that the requested seqid is in the file and check the start and end coordinates
        # Get coordinates if not given and verify the given coordinates
        if self.verbose: print ("Check coordinates")
        if not seqid in  ##### self.seqid_dict #####:
            raise UserWarning ("Seqid {} not found in the reference file".format(seqid))
        if not start or start < 0:
            start = 0         
        if not end or end >  ##### self.seqid_dict #####[seqid]:
            end =  ##### self.seqid_dict #####[seqid]    
        if start >= end:
            raise UserWarning ("Invalid start end coordinates".format(seqid))
        
        # Parse alignment
        if self.verbose: print ("Parse alignment files")
        if not alignment_tracks:
            alignment_tracks = self.alignment_dict.keys()
        alignment_track_dict = OrderedDict()
        alignment_track_count = 0
        for track_name in alignment_tracks:
            d = self._parse_alignment(
                track_name=track_name,
                seqid=seqid,
                start=start,
                end=end,
                n_step=alignment_n_step,
                mode=alignment_mode)
            alignment_track_count += len(d)
            alignment_track_dict[track_name] = d
        
        # Parse annotations
        if self.verbose: print ("Parse annotation files")
        if not annotation_tracks:
            annotation_tracks = self.annotation_dict.keys()
        annotation_track_dict = OrderedDict()
        annotation_track_count = 0
        for track_name in annotation_tracks:
            d = self._parse_annotation (
                track_name=track_name,
                seqid=seqid,
                start=start,
                end=end,
                feature_types=annotation_feature_types,
                overlap_offset=annotation_overlap_offset,
                max_level=annotation_max_level)
            annotation_track_count += len(d)
            annotation_track_dict[track_name] = d
            
        # Prepare the multipanel figure for plotting
        total_height = alignment_track_count*(alignment_track_height+1)
        total_height+= annotation_track_count*annotation_track_height + len(annotation_track_dict)

        pl.style.use(plot_style)
        fig = pl.figure(figsize=(track_width, total_height), frameon=False)
        grid = GridSpec(total_height, 1, hspace=0.01)
        
        # Initial level for the first subplot
        h=0
        if self.verbose: print ("Plot alignment tracks")
        for track_name, coord_dict in alignment_track_dict.items():
            if self.verbose: print ("\tTrack name: {}".format(track_name))
            h+=1
            # Define the plotting area for the current track
            subplot = pl.subplot(grid[h:h+alignment_track_height])
            h+=alignment_track_height
                    
            # Tweak the subplot
            subplot.set_xlim((start, end))
            subplot.yaxis.set_tick_params(left=False, right=False, labelleft=True, labelright=False)
            subplot.xaxis.set_tick_params(bottom=False, top=False, labelbottom=True, labeltop=False)
            subplot.ticklabel_format(useOffset=False, style='plain')
            subplot.set_title(track_name)
            
            if alignment_yscale == "log":
                if any(coord_dict["y"]) <= 0:
                    warnings.warn("Data has no positive values, and therefore can not be log-scaled.")
                else:
                    subplot.set_yscale("log")
            
            # Plot the area
            subplot.fill_between(coord_dict["x"], 0, coord_dict["y"])
        
        if self.verbose: print ("Plot annotation tracks")
        for track_name, feature_dict in annotation_track_dict.items():
            color_list = color_palette(len(feature_dict) ,"Set2")
            if self.verbose: print ("\tTrack name: {}".format(track_name))
            h+=1
            for i, (feature_type, level_dict) in enumerate(feature_dict.items()):
                if self.verbose: rint ("\t\tPloting feature: {}".format(feature_type))
                
                # Define the ploting area for the current track
                subplot = pl.subplot(grid[h:h+annotation_track_height])
                h+=annotation_track_height
                
                # Tweak the subplot
                subplot.set_xlim((start, end))
                subplot.set_ylim((0, len(level_dict)+1))
                subplot.yaxis.set_tick_params(left=False, right=False, labelleft=False, labelright=False)
                subplot.ticklabel_format(useOffset=False, style='plain')
                subplot.set_ylabel(feature_type)
                subplot.grid(axis="y", b=False)
                # Title only for first line
                if i == 0:
                    subplot.set_title(track_name)
                # xlabel only for last line
                if i == len(feature_dict)-1:
                    subplot.xaxis.set_tick_params(bottom=False, top=False, labelbottom=True, labeltop=False)
                else:
                    subplot.xaxis.set_tick_params(bottom=False, top=False, labelbottom=False, labeltop=False)
                
                for level, list_line in level_dict.items():                   
                    for line in list_line:
                        # Scale the arrow depending of the number of lines
                        arrowstyle = "{style},head_width={width},head_length={lenght}".format(
                            style="-|>",  width=6/len(level_dict)+1, lenght=12/len(level_dict)+1)

                        # Plot the arrow
                        subplot.add_patch(arrow (
                            posA=[line.true_start,level+1],
                            posB=[line.true_end,level+1],
                            arrowstyle=arrowstyle,
                            linewidth=12/len(level_dict)+1,
                            edgecolor=color_list[i],
                            facecolor=color_list[i]))
                        # Add text
                        if annotation_label:
                            mid = line.true_start+(line.true_end-line.true_start)/2
                            if start <= mid <= end:
                                subplot.text (x=mid, y=level+1, s=line.ID, horizontalalignment="center")
 
